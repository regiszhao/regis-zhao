<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>Digital Circuits and Verilog Review</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://regiszhao.github.io/css/styles.css></head><body><header>===============<br>== <a href=https://regiszhao.github.io/>regiszhao</a> ==<br>===============<div style=float:right>Currently trying to pass third year.</div><br><p><nav><a href=/about/><b>About</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/notes/><b>Notes</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p></header><main><article><h1>Digital Circuits and Verilog Review</h1><b>Published <time>Sep 26, 2022</time>,
Last modified <time>Oct 2, 2022</time></b>
<a href=/tags/work>work</a>
<a href=/tags/school>school</a><div><p>I have a job interview coming up that requires knowledge of digital circuits and Verilog. Of course I&rsquo;ve already forgotten everything I learned in ECE253 so I&rsquo;ve decided to make some notes as a post for review.</p><h1 id=part-1-logic-circuits>Part 1: Logic Circuits</h1><h3 id=logic-expressions-and-logic-gates>Logic Expressions and Logic Gates</h3><ul><li>transistors are essentially on (x = 1) / off (x = 0) switches<ul><li>can imagine them as a varying value resistor</li></ul></li><li>we can make a simple circuit using the switch and a lightbulb:</li></ul><figure><img src=images/lxx.png alt="Simple connection of a light switch to battery." width=300px><figcaption><p>Simple connection of a light switch to battery.</p></figcaption></figure><ul><li>if x = 1, then L = 1; if x = 0, then L = 0</li><li>i.e. L(x) = x</li><li>this is an example of a basic logic function/expression</li></ul><h3 id=basic-logic-gates-and-or-not>Basic Logic Gates: AND, OR, NOT</h3><ol><li><p>AND: two switches in series<figure><img src=images/andCircuit.png alt="Logical AND circuit." width=300px><figcaption><p>Logical AND circuit.</p></figcaption></figure>- L turns on only if both x1 and x2 are 1 - i.e. L = x1 * x2 - &lsquo;*&rsquo; means AND</p></li><li><p>OR: two switches in parallel<figure><img src=images/orCircuit.png alt="Logical OR circuit." width=300px><figcaption><p>Logical OR circuit.</p></figcaption></figure>- L turns on if either or both x1 = 1, x2 = 1 - i.e. L = x1 + x2 - &lsquo;+&rsquo; means OR</p></li><li><p>NOT: switch and light in parallel</p><ul><li>when x = 1, L = 0; x = 0, L = 1</li><li>i.e. L = !x</li></ul></li></ol><h3 id=truth-tables>Truth Tables</h3><ul><li>tables that display inputs and outputs of a logic function</li><li>e.g. truth table for AND and OR:<figure><img src=images/truthTable.png alt="Truth table for AND and OR." width=200px><figcaption><p>Truth table for AND and OR.</p></figcaption></figure></li></ul><h3 id=logic-gate-circuits>Logic Gate Circuits</h3><ul><li>also called &ldquo;gate level schematics&rdquo;</li><li>logic gate circuit symbols for AND, OR, and NOT:<figure><img src=images/logicGates.png alt="Logic gate circuit symbols." width=300px><figcaption><p>Logic gate circuit symbols.</p></figcaption></figure></li></ul><h3 id=boolean-algebra>Boolean Algebra</h3><ul><li>an effective means to describe logic circuits</li><li>consists of a set of rules derived from axioms</li></ul><h4 id=axioms>Axioms</h4><ol><li>0 * 0 = 0</li><li>1 * 1 = 1</li><li>0 * 1 = 1 * 0 = 0</li><li>if x = 0, !x = 1</li></ol><ul><li><strong>Duality</strong>: we can swap 0 with 1 and * with + in a logic expression and it will remain the same</li></ul><h4 id=rules-derived-from-axioms>Rules derived from axioms</h4><h4 id=identities>Identities</h4><h3 id=terminology-and-notation>Terminology and Notation</h3><ul><li><strong>Literal</strong>: any variable or its complement (e.g. x, !y)</li><li><strong>Product term</strong>: synonym for AND</li><li><strong>Sum term</strong>: synonym for OR</li><li><strong>Sum of products (SOP)</strong>: an OR of ANDs (e.g. xy + !x!y)</li><li><strong>Minterm</strong>: a product term that evaluates to 1 for exactly 1 row of the truth table</li><li><strong>Canonical SOP</strong>: SOP expression for a function that comprises ts minterms</li><li><strong>Maxterm</strong>: sum term that is 0 for exactly 1 row of truth table</li><li><strong>Canonical POS</strong>: product of sums (POS) expression for a function that comprises its maxterms</li></ul><figure><img src=images/minMaxTerms.png alt="Three-variable minterms and maxterms." width=300px><figcaption><p>Three-variable minterms and maxterms.</p></figcaption></figure><ul><li>Example: f(x, y, z) = sum[m(0, 1, 2, 3, 6, 7)]<ul><li>canonical SOP: f = !x!y!z + !x!yz + !xy!z + !xyz + xy!z + xyz</li><li>simplifying the expression gives: f = !x + y</li></ul></li><li>for ANY given function, we can cover its 1s using SOP or its 0s using POS</li></ul><h3 id=nand-and-nor>NAND and NOR</h3><ul><li>NAND = NOT AND</li><li>NOR = NOT OR</li><li>every SOP circuit can be implemented as NAND-NAND, i.e. NAND gates are functionally complete (can implement all logic functions)</li><li>every POS circuit can be implemented as NOR-NOR</li></ul><h3 id=multiplexers>Multiplexers</h3><ul><li>say we design a circuit that controls a light f from either of 2 switches, x or y (called data inputs)</li><li>the switch that selects x or y is controlled by input s (called the select input)</li><li>if s = 0, f is controlled by x; else y</li><li>logic function: f = !sx + sy</li><li>this logic circuit is called a <strong>2 to 1 multiplexer (MUX)</strong><figure><img src=images/multiplexer.png width=400px></figure></li><li>we can have multi-bit wide multiplexers as well</li></ul><h3 id=exclusive-or-and-adders>Exclusive-OR and Adders</h3><ul><li>XOR: f = !xy + x!y</li><li>in Verilog: f = x^y</li><li>when one of the inputs is logic 1, the output is inverse of second input<figure><img src=images/xor.png alt="XOR representations." width=400px><figcaption><p>XOR representations.</p></figcaption></figure></li></ul><h4 id=binary-addition>Binary Addition</h4><ul><li>circuit component called &ldquo;full adder&rdquo; that performs binary addition</li><li>takes 3 inputs: x, y, and c_in (carry in)</li><li>2 outputs: s (sum) and c_out (carry out)</li><li>logic function for c_out = xy + xc_in + yc_in<ul><li>c_out = 1 if two or more inputs are 1</li></ul></li><li>logic function for s = c_in^x^y<ul><li>s = 1 if there are an odd number of inputs that are 1</li></ul></li><li>3-bit ripple carry adder:<ul><li>performs addition of 2 3-bit numbers</li><li>the carry (c_out) can ripple from least significant bit to most significant bit</li></ul></li></ul><h3 id=verilog-introduction>Verilog Introduction</h3><ul><li>example: 2 to 1 MUX</li></ul><pre tabindex=0><code>module mux2to1(x, y, s, f);
    input x, y, s;
    output f;
    assign f = (~s &amp; x) | (s &amp; y)
end module
</code></pre><ul><li>keywords in Verilog:<ul><li><strong>module</strong> &ndash; kind of like function declaration</li><li><strong>end module</strong> &ndash; ends the module declaration</li><li><strong>input/output</strong> &ndash; specifies input/output signal</li><li><strong>assign</strong> &ndash; kind of like variable assignment; assigns a logic expression to signal but think of it as wiring up signals to produce a continuously driven value<ul><li>assign statements occur concurrently so order of assign statements doesn&rsquo;t matter</li></ul></li></ul></li><li>the signal names inside the brackets after the module name are the name of input/output <strong>ports</strong> of the module</li><li>to actually build this on the DE1-SoC board, we need to map the signal/port names to the actual switch and LED components on the board</li><li>say we use switch 1 and 0 for x and y, switch 9 for s, and f to appear on LED 0:</li></ul><pre tabindex=0><code>module mux2to1(SW, LEDR);
    input [9:0]SW; // the [9:0] tells us SW is 10 bits long
    output[9:0]LEDR;
    wire x, y, s, f;
    assign s = SW[9];
    assign y = SW[1];
    assign x = SW[0];
    assign f = (~s &amp; x) | (s &amp; y)
    assign LEDR[0] = f;
end module
</code></pre><ul><li><strong>wire</strong> data type that represents intermediate signals &ndash; can think of them as literally physical wires connecting signals</li></ul><h4 id=hierarchical-verilog>Hierarchical Verilog</h4><ul><li>similar to functions in programming</li><li>example: we will create a full adder, then use instances of it to create a 3 bit ripple carry adder:</li></ul><pre tabindex=0><code>module FA(a, b, cin, s, cout);
    input a, b, cin;
    output s, cout;
    assign s = a ^ b ^ cin;
    assign cout = (a &amp; b) | (a &amp; cin) | (b &amp; cin);
end module

/* this is a top level module -
- it uses FA module within and no other modules use adder3 in them */
module adder3(A, B, cin, S, cout);
    input [2:0] A, B;
    input cin;
    output [2:0] S;
    output cout;
    wire c1, c2;
    FA U0(A[0], B[0], cin, S[0], c1);
    FA U1(A[1], B[1], c1, S[1], c2);
    FA U2(A[2], B[2], c2, S[2], cout);
end module
</code></pre><h3 id=introduction-to-fpgas-and-cad-tools>Introduction to FPGAs and CAD Tools</h3><ul><li>for most chips, function is fixed at the time of manufacture</li><li>Field Programmable Gate Arrays (FPGAs) are configurable by user<ul><li>programmable hardware &ndash; can implement any digital circuit</li><li>reconfigurable</li><li>cheaper than custom chips in moderate volume</li></ul></li><li>implementing logic in FPGAs:<ul><li>often done with look-up tables (LUTs) &ndash; hardware implementation of truth table, has small memory that holds output values for each input combination</li></ul></li><li>CAD &ndash; computer aided design tool to turn HDL into bitstream</li></ul><h3 id=more-verilog-examples>More Verilog Examples</h3><h4 id=2-to-1-mux-2-bit>2 to 1 MUX 2-bit</h4><pre tabindex=0><code>module mux2to1-2bit(X, Y, s, F);
    input s;
    input [1:0] X, Y;
    output [1:0] F;
    assign F[1] = (~s &amp; X[1]) | (s &amp; Y[1]);
    assign F[0] = (~s &amp; X[0]) | (s &amp; Y[0]);
end module
</code></pre><ul><li>note: we must assign an expression to each bit of F individually because s is only 1 bit, while X and Y are 2 bits<ul><li>Verilog will turn s into a vector (like X and Y) by adding zeros</li><li>this won&rsquo;t work properly if s is 1</li></ul></li><li>we could use <strong>bit concatenation</strong> {} to make a vector:<ul><li>i.e. F = ({~s, ~s} & X) | ({s, s} & Y)</li></ul></li></ul><h3 id=introduction-to-karnaugh-maps>Introduction to Karnaugh Maps</h3><ul><li><strong>Karnaugh Map</strong>: type of truth table used to easily minimize logic expressions &ndash; minterms that can be combined to form a term are adjacent<figure><img src=images/kmap.png alt="4 variable K-map." width=250px><figcaption><p>4 variable K-map.</p></figcaption></figure></li></ul><h4 id=k-map-terminology>K-Map Terminology</h4><ul><li><strong>Implicant</strong>: a product term P is an implicant of boolean function F if P imples F, i.e. F = 1 whenever P = 1</li><li><strong>Prime Implicant (PI)</strong>: an implicant that can&rsquo;t be accounted/covered for by a more general (fewer literals) implicant</li><li><strong>Essential PI</strong>: a PI that covers at least 1 minterm not covered by any other PI</li><li><strong>Cover</strong>: any set of implicants that cover all minterms of a function &ndash; describes the function, always want to find minimum cost cover<ul><li>cost = # gates + # inputs</li><li>product terms that cover more adjacent cells are cheaper</li></ul></li></ul><h4 id=procedure-for-finding-min-cost-cover>Procedure for Finding Min-Cost Cover:</h4><ol><li>Find PIs</li><li>Identify essential PIs and include in the cover</li><li>Choose other PIs as needed until all minterms are covered such that # of literals is minimized<ul><li>don&rsquo;t always choose largest group of 1&rsquo;s &ndash; some special cases where choosing smaller groups end up being cheaper</li></ul></li></ol><h4 id=dont-cares>Don&rsquo;t Cares</h4><ul><li>sometimes we know specific values of inputs won&rsquo;t occur, or if they do, we don&rsquo;t care what output is produced in those cases</li><li>e.g. a 7-seg display can only show up to decimal 9, which requires 4 bits to represent in binary, but 4 bits can represent up to 15 in decimal, so for input numbers 10-15, it doesn&rsquo;t matter what the output of the 7-seg display is since we know it will never happen</li></ul><h1 id=part-2-sequential-circuits>Part 2: Sequential Circuits</h1><ul><li><strong>Combinational Circuits</strong>: output only determined by present input</li><li><strong>Sequential Circuits</strong>: output determined by present and previous inputs<ul><li>allows us to store information</li></ul></li></ul><h3 id=rs-latch>RS Latch</h3><ul><li>think of an alarm clock &ndash; need to be able to <em>set</em> it off and also <em>reset</em> it</li><li>RS = reset/set</li><li>memory circuits have feedback loops in the circuit since they need to reference previous values in the circuit</li><li>RS latch: cross coupled NOR gates<figure><img src=images/rsLatch.png alt="RS latch circuit and characteristic table." width=400px><figcaption><p>RS latch circuit and characteristic table.</p></figcaption></figure></li><li>when S = R = 0, the output of their NOR gates will be the opposite of the other input, so we&rsquo;ll either have Q = 1 and !Q = 0, or Q = 0 and !Q = 1</li><li>when you reset the latch (R = 1), the output Q will be 0 no matter what</li><li>when you set the latch (S = 1), the output !Q will be 0 no matter what, and given that R = 0, then Q = 1 (alarm is set off)</li><li>when you set S = R = 1, both Q and !Q equal 0 &ndash; this violates the purpose of Q and !Q<ul><li>is bad and can lead to oscillations in Q and !Q</li><li>if you simultaneously turn S and R to 0, it causes Q and !Q to both change to 1, but if they&rsquo;re both 1, they must be 0 since they are each other&rsquo;s inputs, but if both 0 then they are 1&mldr;</li></ul></li></ul><h3 id=gated-d-latch-and-the-clock-signal>Gated D Latch and the Clock Signal</h3><ul><li>add a clock input (square wave) to RS latch to disable/enable it</li><li>AND the clock input with the R and S input so when clock = 0, R&rsquo; and S&rsquo; are 0</li><li>when R&rsquo; and S&rsquo; are 0, the value of Q and !Q are stored<figure><img src=images/gatedSRLatch.png alt="Gated SR Latch." width=500px><figcaption><p>Gated SR Latch.</p></figcaption></figure></li><li>we can also represent the circuit using only NAND gates</li></ul><h4 id=gated-d-latch>Gated D Latch</h4><ul><li>if we let D = S, !D = R, we can avoid the S = R = 1 case, and have created a gated D latch:<figure><img src=images/gatedDLatch.png alt="Gated D Latch." width=500px><figcaption><p>Gated D Latch.</p></figcaption></figure></li><li>D is the &ldquo;data input&rdquo;</li><li>when clock = 0, Q&rsquo;s value is stored</li><li>when clock = 1, Q follows D</li></ul><h4 id=new-verilog-statements-for-sequential-circuits>New Verilog Statements for Sequential Circuits</h4><ul><li>always block, if-else, case</li><li>example: multiplexer &ndash; s == 0 ? f = x1 : f = x2</li></ul><pre tabindex=0><code>module mux(x1, x2, s, f);
    input x1, x2, s;
    output reg f;

    always @(x1, x2, s) // the sensitivity list (inside the brackets)
    begin
        if (s == 0)
            f = x1;
        else
            f = x2;
    end

end module
</code></pre><ul><li>the always block is a procedural block &ndash; statements inside of it are executed <em>sequentially</em></li><li>the sensitivity list gives us the signals that can directly affect assignment mode in always block &ndash; always block is executed whenever a signal in the sensitivity list changes<ul><li>often written as &ldquo;always @(*)&rdquo; for combinational circuits, where * means wildcard</li></ul></li><li>any signal assigned a value in an always block must be declared as type reg</li><li>some types of statements (if/else, case) must be written in always block</li><li>example: 7 seg display for numbers 0-9:</li></ul><pre tabindex=0><code>module seg7(SW, HEX0);
    input [3:0]SW;
    output reg [6:0]HEX0;
    always @(*)
    begin
        case(SW)
            4&#39;b0000: HEX0 = 7&#39;b1000000;
            4&#39;b0000: HEX0 = 7&#39;b1111001;
            .
            .
            .
            4&#39;b1001: HEX0 = 7&#39;b0010000;
            default: HEX0 = 7&#39;bxxxxxxx;
        end case
    end
end module
</code></pre><ul><li>note: default clause covers the cases that were not accounted for &ndash; very important to include since without it, the compiler will generate latches and things will potentially not behave the way they should</li></ul><h3 id=d-flip-flops>D Flip Flops</h3><ul><li>similar to gated D latch, except Q will only change on clock edges<figure><img src=images/dFF.jpg alt="D flip flop." width=300px><figcaption><p>D flip flop.</p></figcaption></figure></li><li>case 1: clock = 0, then Qp = D, Q = Q(t-1) (stored value)</li><li>case 2: clock -> 1, Q = Qp = D</li><li>basically when clock rises to 1, the value of D at that moment is stored</li></ul><h4 id=verilog-for-sequential-circuits>Verilog for Sequential Circuits</h4><p>The D latch:</p><pre tabindex=0><code>module D-latch(D, clk, Q);
    input D, clk;
    output reg Q;
    always @(D, clk)
    begin
        if (clk == 1&#39;b1)
            Q = D;
    end
</code></pre><ul><li>notice how no else clause is used &ndash; a latch is automatically created, i.e. Q is stored if clk != 1&rsquo;b1, though this is probably bad practice</li></ul><p>D Flip-Flop:</p><pre tabindex=0><code>module D-ff(D, clk, Q)
    input D, clk;
    output reg Q;
    always @(posedge clk)
    begin
        Q &lt;= D;
    end
end module
</code></pre><ul><li>notice D is not included in sensitivity list this time because changes in D&rsquo;s value don&rsquo;t directly change value of FF</li><li>we refer to signals going from 0 to 1 as <strong>positive (rising) edge</strong> (posedge) and 1 to 0 as <strong>negative (falling) edge</strong> (negedge)</li><li>we use &ldquo;&lt;=&rdquo; to assign values in FFs</li><li>one FF can only store 1 bit of information</li><li><strong>register</strong>: a set of <em>n</em> FFs used to store <em>n</em> bits of information, all sharing the same clock signal<ul><li>e.g. 8-bit register in Verilog: essentially same as an FF but D and Q are 8 bits long</li></ul></li></ul><pre tabindex=0><code>module reg8(D, clk, Q);
    input [7:0]D;
    input clk;
    output reg [7:0]Q;
    always @(posedge clk);
    begin
        Q &lt;= D;
    end
end module
</code></pre><h3 id=t-flip-flops-counters>T-Flip Flops, Counters</h3><ul><li>useful abstractions for counter designs<figure><img src=images/tFF.gif alt="T-flip flop circuit." width=300px><figcaption><p>T-flip flop circuit.</p></figcaption></figure><figure><img src=images/tFF.png alt="T-flip flop characteristic." width=300px><figcaption><p>T-flip flop characteristic.</p></figcaption></figure></li><li>at rising clock edge:<ul><li>if T = 0, Q(t) is stored</li><li>if T = 1, !Q(t) is stored</li></ul></li><li>essentially T FFs toggle when T = 1</li></ul><h4 id=3-bit-counter>3-bit counter</h4><ul><li>we can use T-FFs to make a sequential counter (000, 001, 010, etc.)</li><li>count advances at each rising clock edge<figure><img src=images/3bitCounterTable.png alt="3-bit counter table." width=300px><figcaption><p>3-bit counter table.</p></figcaption></figure></li><li>notice Q0 toggles every cycle</li><li>Q1 toggles when Q0 = 1 in previous cycle</li><li>Q2 toggles when both Q0 = Q1 = 1 in previous cycle</li><li>example of a 4-bit counter:<figure><img src=images/3bitCounter.png alt="3-bit counter circuit." width=400px><figcaption><p>3-bit counter circuit.</p></figcaption></figure></li><li>see how in this circuit:<ul><li>Q0 always toggles</li><li>Q1 toggles when Q0 = 1</li><li>Q2 toggles when Q0 AND Q1 = 1</li></ul></li><li>for Qn, T = Q0 * Q1 * Q2 * &mldr; * Q(n-1)</li></ul><h4 id=3-bit-counter-with-enable>3-bit counter with &ldquo;enable&rdquo;</h4><ul><li>when &ldquo;enable&rdquo; input = 1, count as usual; if enable = 0, stop counting (hold/store value)</li><li>enable is ANDed with the inputs of the FFs so if enable = 0, the inputs into the FFs are 0</li></ul><h4 id=3-bit-counter-with-enable-and-parallel-load>3 bit counter with enable and parallel load</h4><ul><li>allows you to preload counter with new value D2, D1, D0<figure><img src=images/3bitCounterLoad.png alt="3-bit counter circuit with parallel load capability." width=300px><figcaption><p>3-bit counter circuit with parallel load capability.</p></figcaption></figure></li><li>Verilog:</li></ul><pre tabindex=0><code>module upcount(R, resetn, clock, E, L, Q);
    input [3:0]R;
    input resetn, clock, E, L;
    output reg [3:0]Q;
    always @(posedge clock, negedge resetn)
    begin
        if (!resetn)
            Q &lt;= 4&#39;b0000
        else if (L)
            Q &lt;= R;
        else if (E)
            Q &lt;= Q + 1 // addition
    end
end module
</code></pre><ul><li>note: adding 0b1111 + 1 should equal 0b10000, but since Q is only 4 bits, it will overflow and will equal 0b0000</li></ul><h4 id=3-bit-down-counter>3 bit down counter</h4><ul><li>Q0 toggles every cycle, Q1 toggles when Q0 = 0, Q2 toggles when Q1 and Q0 = 0</li></ul><h3 id=resets-and-sets-on-flip-flops>Resets and Sets on Flip Flops</h3><ul><li>we want to make a positive edge triggered FF with <strong>active low synchronous reset</strong><ul><li>active low: 0 state causes reset</li><li>synchronous reset: reset happens on clock edge</li></ul></li><li>we can achieve this by ANDing reset input with the D input so that when reset = 0, the input into the FF is 0</li><li>in Verilog:</li></ul><pre tabindex=0><code>module dffreset(D, resetn, clock, Q);
    input D, resetn, clock;
    output reg Q;
    always @(posedge clock)
    begin
        if (resetn = 1&#39;b0)
            Q &lt;= 1&#39;b0;
        else:
            Q &lt;= D;
    end
end module
</code></pre><ul><li><strong>active low asynchronous reset</strong>: reset can happen anytime (not just on clock edge)</li></ul><pre tabindex=0><code>module DFF-resetn(D, resetn, clock, Q);
    input D, resetn, clock;
    output reg Q;
    always @(posedge clock, negedge resetn)
    begin
        if (resetn = 1&#39;b0)
            Q &lt;= 1&#39;b0;
        else
            Q &lt;= D;
    end
end module
</code></pre><h2 id=part-3-finite-state-machines>Part 3: Finite State Machines</h2><h3 id=introduction-to-finite-state-machines>Introduction to Finite State Machines</h3><ul><li>general model of any sequential circuit:<figure><img src=images/generalSeqCircuit.png alt="General structure of sequential circuit with input w and output z." width=400px><figcaption><p>General structure of sequential circuit with input w and output z.</p></figcaption></figure></li><li>the present state is represented by y1&mldr;yk</li><li>the next states, Y1&mldr;Yk, are a function of input w and present state y1&mldr;yk through a combinational circuit and are stored in FFs (1 FF needed for each bit)</li><li>the output z is a function of present states y1&mldr;yk through a combinational circuit</li><li>to design a sequential circuit 1. State Diagram 2. State Table 3. State Assignment 4. State-Assigned Table 5. Synthesize Circuit<figure><img src=images/stateDiagram.png alt="Example state diagram." width=400px><figcaption><p>Example state diagram.</p></figcaption></figure><figure><img src=images/exampleStateTable.png alt="Example state table for the state diagram above." width=200px><figcaption><p>Example state table for the state diagram above.</p></figcaption></figure></li><li>note: a series connection of D-FFs is a shift register &ndash; shifts bits through the registers on rising/falling clock edge</li><li>general structure of an FSM in Verilog has 3 sections:<ol><li>State table</li><li>FFs</li><li>Output</li></ol></li></ul><pre tabindex=0><code>module FSM(w, clock, resetn, z);
    input w, clock, resetn;
    output z;
    reg [2:1] y, Y;

    // can parameterize states here as well
    parameter A = 2&#39;b00, B = 2&#39;b01, ... ;

    // state table (deciding next state based on present and input) using case statement
    always @(w, y)
    begin
        case(y)
            A: if (w) ... else ...
            B: if (w) ... else ...
        endcase
    end

    // FFs -- making y = Y or resetting
    always @(posedge clock)
    begin
        if (!resetn)
            y &lt;= A;
        else
            y &lt;= Y;
    end

    // FSM Output
    assign z = ...

end module
</code></pre><h4 id=1-hot-encoding>1 Hot Encoding</h4><ul><li>using 1 bit to represent each state<ul><li>e.g. 4 states can be represented by only 2 bits, but with 1 hot encoding:<ul><li>A: 0001, B: 0010, C: 0100, D: 1000</li></ul></li></ul></li><li>can create logic expressions for next states Y1&mldr;Yk and output z by simply inspecting state diagram (sometimes table not needed)<ul><li>this creates different circuits than if we had only used different numbers for different states, but has the same functionality</li></ul></li></ul><h3 id=shift-register>Shift Register</h3><ul><li>for FSMs detecting patterns, we use shift registers<ul><li>e.g. detect last 3 values of w; if 101, then z = 1</li></ul></li></ul><h2 id=part-4-digital-system-design>Part 4: Digital System Design</h2><h3 id=signed-numbers-and-addersubtractor-unit>Signed Numbers and Adder/Subtractor Unit</h3><ul><li>to represent negative numbers, we use 2&rsquo;s complement representation</li><li>quick way to find 2&rsquo;s complement: flip all bits, then add 1</li></ul><h4 id=4-bit-addersubtractor-unit>4-bit Adder/Subtractor Unit</h4><ul><li>single unit to add AND subtract:<ul><li>subtracts if input sub = 0 (otherwise adds)<figure><img src=images/addSubUnit.png alt="Adder/Subtractor Unit." width=500px><figcaption><p>Adder/Subtractor Unit.</p></figcaption></figure></li></ul></li><li>if sub = 1, the XOR gates will flip the y bits and the c_in will add 1 in order to convert y into negative</li><li>if sub = 0, the y bits remain the same and the unit adds</li></ul><h3 id=bus-structure>Bus Structure</h3><ul><li>suppose we have a digital system with n-bit registers, and we want it to be able to transfer data between registers</li><li>to do this, we connect each register to a common set of n wires, used to transfer data into and out of the registers</li><li>these wires are called a <strong>bus</strong></li><li>it is necessary to ensure that only one register acts as a source at any given time</li></ul><h4 id=tri-state-driverbuffer>Tri-State Driver/Buffer</h4><ul><li>in practical situations, outputs of logic gates cannot be connected together because a short circuit would result if one gate forces 1 while the other forces 0</li><li>therefore, if the outputs of two registers need to be connected to a common set of wires, we use a <strong>tri-state driver/buffer</strong><figure><img src=images/triStateDriver.png alt="Tri-state driver/buffer." width=500px><figcaption><p>Tri-state driver/buffer.</p></figcaption></figure></li><li>essentially a switch, but when e = 0, the output is electrically disconnected from the data input w, referred to as a <em>high impedance</em> state denoted by Z</li></ul><h4 id=implementing-a-bus>Implementing a Bus</h4><figure><img src=images/busStructure.png alt="Using tri-state drivers to implement a bus." width=500px><figcaption><p>Using tri-state drivers to implement a bus.</p></figcaption></figure><ul><li>the data outputs of each register are connected to tri-state drivers<ul><li>if selected by their enable signals (R1out, &mldr;, Rkout), the drivers place the corresponding register&rsquo;s contents onto the bus wires</li></ul></li><li>each register also has an enable input (R1in, &mldr;, Rkin) which when set to 1, allows its contents to be changed on the next active edge of the clock</li><li>in real systems, other types of circuit blocks would be connected to the bus, controlled by the control input &ldquo;Extern&rdquo;</li><li>the entire structure is called the <strong>datapath</strong></li><li>the signals that control the flow of data through the datapath (e.g. R1in - Rkin, R1out - Rkout, Extern, etc.) are generated by the <strong>control circuit/FSM</strong></li><li>the control circuit could perform a number of functions, e.g. transferring data from one register to another, adding, etc.</li><li>the input signal &ldquo;Function&rdquo; specifies a task which tells the control circuit what signals to produce</li><li>the control circuit and registers are all controlled by the same clock signal</li></ul><h3 id=introduction-to-processors>Introduction to Processors</h3><ul><li>an example of a simple processor:<figure><img src=images/processor.png alt="Simple processor." width=700px><figcaption><p>Simple processor.</p></figcaption></figure><figure><img src=images/opTable.png alt="Operations performed in the processor." width=300px><figcaption><p>Operations performed in the processor.</p></figcaption></figure></li><li>the specific operation to be performed at any given time is indicated by the control circuit input &ldquo;Function&rdquo;</li><li>an operation is initiated by setting w = 1</li><li>when operation is completed, the control circuit outputs &ldquo;Done&rdquo; = 1</li></ul></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/2022-09-26-digital-circuits-and-verilog-review/>Digital Circuits and Verilog Review</a></li><li><a href=/notes/>University Notes</a></li><li><a href=/posts/2022-09-11-sickkids-internship/>SickKids Internship</a></li><li><a href=/posts/2022-09-11-trip-to-bc/>Trip to BC</a></li><li><a href=/about/>About</a></li></ul></div></div></aside><footer><p>&copy; 2022 <a href=https://regiszhao.github.io/><b>regiszhao</b></a>.
<a href=https://github.com/example><b>Github</b></a>.
<a href=https://example.com/@user><b>Mastodon</b></a>.
<a href=/imprint><b>Imprint</b></a>.</p></footer></body></html>